<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ASCII Particle Fluid Simulation – Orientation Driven</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; }
      canvas { display: block; }
      #enableButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        padding: 20px 40px;
        background: #222;
        color: #fff;
        border: none;
        cursor: pointer;
        font-size: 24px;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include AsciiEffect from an alternative CDN with crossorigin -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/effects/AsciiEffect.js" crossorigin="anonymous"></script>
    <script>
      // Set up scene, camera, and renderer.
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Wrap the renderer with the ASCIIEffect.
      const effect = new THREE.AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
      effect.setSize(window.innerWidth, window.innerHeight);
      effect.domElement.style.color = 'lime';
      effect.domElement.style.backgroundColor = 'black';
      document.body.appendChild(effect.domElement);
      
      // Create a particle system.
      const particleCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const range = 5;
      
      // Initialize particles with random positions; start with zero velocity.
      for (let i = 0; i < particleCount; i++) {
          positions[i * 3]     = (Math.random() - 0.5) * range;
          positions[i * 3 + 1] = (Math.random() - 0.5) * range;
          positions[i * 3 + 2] = (Math.random() - 0.5) * range;
          
          velocities[i * 3]     = 0;
          velocities[i * 3 + 1] = 0;
          velocities[i * 3 + 2] = 0;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Points material – the ASCII effect will convert the scene to text.
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Gravity vector (or target velocity) influenced by device orientation.
      let gravity = new THREE.Vector3(0, 0, 0);
      
      // Orientation handler: apply stronger multipliers and invert Y so it pulls down.
      function handleOrientation(event) {
          // event.beta: front-to-back tilt (-180 to 180)
          // event.gamma: left-to-right tilt (-90 to 90)
          let beta  = event.beta  || 0;
          let gamma = event.gamma || 0;
          // Increase the multiplier for a stronger effect.
          let gx = THREE.MathUtils.clamp(gamma / 90, -1, 1) * 0.01;
          // Invert beta so tilting forward pulls particles downward.
          let gy = -THREE.MathUtils.clamp(beta / 90, -1, 1) * 0.01;
          gravity.set(gx, gy, 0);
      }
      
      // Request permission for device orientation if needed (iOS 13+).
      function enableMotion() {
          if (typeof DeviceOrientationEvent !== 'undefined' &&
              typeof DeviceOrientationEvent.requestPermission === 'function') {
              DeviceOrientationEvent.requestPermission()
              .then(permissionState => {
                  if (permissionState === 'granted') {
                      window.addEventListener("deviceorientation", handleOrientation, true);
                  } else {
                      console.log("Permission not granted for DeviceOrientation.");
                  }
              })
              .catch(console.error);
          } else {
              window.addEventListener("deviceorientation", handleOrientation, true);
          }
      }
      
      // Add a big button to request sensor access.
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
          const button = document.createElement('button');
          button.id = "enableButton";
          button.innerHTML = "Enable Motion Controls";
          document.body.appendChild(button);
          button.addEventListener('click', () => {
              enableMotion();
              button.style.display = 'none';
          });
      } else {
          window.addEventListener("deviceorientation", handleOrientation, true);
      }
      
      // Animation loop.
      function animate() {
          requestAnimationFrame(animate);
          const positionsAttr = particles.geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
              // Interpolate particle velocity toward the current gravity vector more quickly.
              velocities[i * 3]     = THREE.MathUtils.lerp(velocities[i * 3], gravity.x, 0.5);
              velocities[i * 3 + 1] = THREE.MathUtils.lerp(velocities[i * 3 + 1], gravity.y, 0.5);
              velocities[i * 3 + 2] = THREE.MathUtils.lerp(velocities[i * 3 + 2], gravity.z, 0.5);
              
              // Add a small random turbulence for extra choppiness.
              let turbulence = 0.002;
              velocities[i * 3]     += (Math.random() - 0.5) * turbulence;
              velocities[i * 3 + 1] += (Math.random() - 0.5) * turbulence;
              velocities[i * 3 + 2] += (Math.random() - 0.5) * turbulence;
              
              // Update particle positions.
              positionsAttr[i * 3]     += velocities[i * 3];
              positionsAttr[i * 3 + 1] += velocities[i * 3 + 1];
              positionsAttr[i * 3 + 2] += velocities[i * 3 + 2];
              
              // Reverse velocity on boundary contact.
              if (positionsAttr[i * 3] < -range/2 || positionsAttr[i * 3] > range/2) {
                  velocities[i * 3] = -velocities[i * 3];
              }
              if (positionsAttr[i * 3 + 1] < -range/2 || positionsAttr[i * 3 + 1] > range/2) {
                  velocities[i * 3 + 1] = -velocities[i * 3 + 1];
              }
              if (positionsAttr[i * 3 + 2] < -range/2 || positionsAttr[i * 3 + 2] > range/2) {
                  velocities[i * 3 + 2] = -velocities[i * 3 + 2];
              }
          }
          particles.geometry.attributes.position.needsUpdate = true;
          effect.render(scene, camera);
      }
      animate();
      
      // Handle window resizing.
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          effect.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
