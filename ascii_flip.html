<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ASCII Particle Fluid Simulation – Fast, Turbulent & Walled</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; }
      canvas, pre { display: block; }
      #enableButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        padding: 20px 40px;
        background: #222;
        color: #fff;
        border: none;
        cursor: pointer;
        font-size: 24px;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include AsciiEffect from an alternative CDN with crossorigin -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/effects/AsciiEffect.js" crossorigin="anonymous"></script>
    <script>
      // Set up scene, camera, and renderer.
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Wrap the renderer with the ASCIIEffect.
      const effect = new THREE.AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
      effect.setSize(window.innerWidth, window.innerHeight);
      // Force white text so something shows up even if vertex colors are ignored.
      effect.domElement.style.color = "#FFF";
      effect.domElement.style.backgroundColor = 'black';
      document.body.appendChild(effect.domElement);
      
      // Function to compute the boundaries for the plane at z = 0 based on camera settings.
      function updateBoundaries() {
        const distance = camera.position.z; // distance from camera to plane
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const height = 2 * Math.tan(fovRad/2) * distance;
        const width = height * camera.aspect;
        return { left: -width/2, right: width/2, bottom: -height/2, top: height/2 };
      }
      
      // Compute boundaries for particle initialization.
      let boundaries = updateBoundaries();
      
      // Create a particle system.
      const particleCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      // Initialize particles within the computed boundaries.
      // Colors are derived from positions (gradient) but note that the default ASCII effect
      // will render all characters in the forced text color.
      for (let i = 0; i < particleCount; i++) {
          let x = Math.random() * (boundaries.right - boundaries.left) + boundaries.left;
          let y = Math.random() * (boundaries.top - boundaries.bottom) + boundaries.bottom;
          let z = (Math.random() - 0.5) * 0.5; // small Z variation
          positions[i * 3]     = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
          
          // Start with zero velocity.
          velocities[i * 3]     = 0;
          velocities[i * 3 + 1] = 0;
          velocities[i * 3 + 2] = 0;
          
          // Gradient color based on position.
          let normX = (x - boundaries.left) / (boundaries.right - boundaries.left);
          let normY = (y - boundaries.bottom) / (boundaries.top - boundaries.bottom);
          colors[i * 3]     = normX;              
          colors[i * 3 + 1] = normY;              
          colors[i * 3 + 2] = 1 - (normX * normY);  
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute('color', new THREE.BufferAttribute(colors, 3));
      
      // Use a PointsMaterial with vertexColors enabled.
      const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.1 });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Gravity (or target velocity) vector driven by device orientation.
      let gravity = new THREE.Vector3(0, 0, 0);
      
      // Orientation handler: apply a high multiplier (0.05) and invert Y so tilting forward pulls particles downward.
      function handleOrientation(event) {
          let beta  = event.beta  || 0;   // front-to-back tilt (-180 to 180)
          let gamma = event.gamma || 0;    // left-to-right tilt (-90 to 90)
          let gx = THREE.MathUtils.clamp(gamma / 90, -1, 1) * 0.05;
          let gy = -THREE.MathUtils.clamp(beta / 90, -1, 1) * 0.05;
          gravity.set(gx, gy, 0);
      }
      
      // Request permission for device orientation if needed (iOS 13+).
      function enableMotion() {
          if (typeof DeviceOrientationEvent !== 'undefined' &&
              typeof DeviceOrientationEvent.requestPermission === 'function') {
              DeviceOrientationEvent.requestPermission()
              .then(permissionState => {
                  if (permissionState === 'granted') {
                      window.addEventListener("deviceorientation", handleOrientation, true);
                  } else {
                      console.log("Permission not granted for DeviceOrientation.");
                  }
              })
              .catch(console.error);
          } else {
              window.addEventListener("deviceorientation", handleOrientation, true);
          }
      }
      
      // Add a large button to request sensor access if required.
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
          const button = document.createElement('button');
          button.id = "enableButton";
          button.innerHTML = "Enable Motion Controls";
          document.body.appendChild(button);
          button.addEventListener('click', () => {
              enableMotion();
              button.style.display = 'none';
          });
      } else {
          window.addEventListener("deviceorientation", handleOrientation, true);
      }
      
      // Animation loop.
      function animate() {
          requestAnimationFrame(animate);
          // Update boundaries (in case of window resizing).
          boundaries = updateBoundaries();
          const positionsAttr = particles.geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
              // Interpolate each particle's velocity toward the current gravity vector (faster with a lerp factor of 0.7).
              velocities[i * 3]     = THREE.MathUtils.lerp(velocities[i * 3], gravity.x, 0.7);
              velocities[i * 3 + 1] = THREE.MathUtils.lerp(velocities[i * 3 + 1], gravity.y, 0.7);
              velocities[i * 3 + 2] = THREE.MathUtils.lerp(velocities[i * 3 + 2], gravity.z, 0.7);
              
              // Increase turbulence for more chaotic motion.
              const turbulence = 0.005;
              velocities[i * 3]     += (Math.random() - 0.5) * turbulence;
              velocities[i * 3 + 1] += (Math.random() - 0.5) * turbulence;
              velocities[i * 3 + 2] += (Math.random() - 0.5) * turbulence;
              
              // Update positions.
              positionsAttr[i * 3]     += velocities[i * 3];
              positionsAttr[i * 3 + 1] += velocities[i * 3 + 1];
              positionsAttr[i * 3 + 2] += velocities[i * 3 + 2];
              
              // Bounce off walls in the X–Y plane.
              if (positionsAttr[i * 3] < boundaries.left) {
                  positionsAttr[i * 3] = boundaries.left;
                  velocities[i * 3] = -velocities[i * 3];
              } else if (positionsAttr[i * 3] > boundaries.right) {
                  positionsAttr[i * 3] = boundaries.right;
                  velocities[i * 3] = -velocities[i * 3];
              }
              if (positionsAttr[i * 3 + 1] < boundaries.bottom) {
                  positionsAttr[i * 3 + 1] = boundaries.bottom;
                  velocities[i * 3 + 1] = -velocities[i * 3 + 1];
              } else if (positionsAttr[i * 3 + 1] > boundaries.top) {
                  positionsAttr[i * 3 + 1] = boundaries.top;
                  velocities[i * 3 + 1] = -velocities[i * 3 + 1];
              }
          }
          particles.geometry.attributes.position.needsUpdate = true;
          effect.render(scene, camera);
      }
      animate();
      
      // Update renderer and effect on window resize.
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          effect.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
