<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ASCII Particle Fluid Simulation with Orientation Permission</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; }
      canvas { display: block; }
      #enableButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        padding: 10px 20px;
        background: #222;
        color: #fff;
        border: none;
        cursor: pointer;
      }
    </style>
  </head>
  <body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include AsciiEffect from an alternative CDN with crossorigin -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/effects/AsciiEffect.js" crossorigin="anonymous"></script>
    <script>
      // Set up scene, camera, and renderer.
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Wrap the renderer with the ASCIIEffect.
      const effect = new THREE.AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
      effect.setSize(window.innerWidth, window.innerHeight);
      effect.domElement.style.color = 'lime'; // ASCII text color
      effect.domElement.style.backgroundColor = 'black';
      document.body.appendChild(effect.domElement);
      
      // Create a particle system.
      const particleCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const range = 5; // simulation area
      
      // Initialize particles with random positions and small random velocities.
      for (let i = 0; i < particleCount; i++) {
          positions[i*3]   = (Math.random() - 0.5) * range;
          positions[i*3+1] = (Math.random() - 0.5) * range;
          positions[i*3+2] = (Math.random() - 0.5) * range;
          
          velocities[i*3]   = (Math.random() - 0.5) * 0.02;
          velocities[i*3+1] = (Math.random() - 0.5) * 0.02;
          velocities[i*3+2] = (Math.random() - 0.5) * 0.02;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Use a PointsMaterial. The ASCII effect will transform the rendering.
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Gravity vector influenced by device orientation.
      let gravity = new THREE.Vector3(0, -0.001, 0);
      
      // Orientation handler: update gravity based on beta (x tilt) and gamma (y tilt).
      function handleOrientation(event) {
          // Log for debugging.
          console.log("Orientation event:", event.beta, event.gamma);
          let beta  = event.beta  || 0;   // front-to-back tilt: -180 to 180
          let gamma = event.gamma || 0;    // left-to-right tilt: -90 to 90
          let gx = THREE.MathUtils.clamp(gamma / 90, -1, 1) * 0.001;
          let gy = THREE.MathUtils.clamp(beta / 90, -1, 1) * 0.001;
          gravity.set(gx, gy, 0);
      }
      
      // Request permission for device orientation if needed (iOS 13+)
      function enableMotion() {
          if (typeof DeviceOrientationEvent !== 'undefined' &&
              typeof DeviceOrientationEvent.requestPermission === 'function') {
              DeviceOrientationEvent.requestPermission()
              .then(permissionState => {
                  if (permissionState === 'granted') {
                      window.addEventListener("deviceorientation", handleOrientation, true);
                  } else {
                      console.log("Permission not granted for DeviceOrientation.");
                  }
              })
              .catch(console.error);
          } else {
              // If permission not required, simply add the event listener.
              window.addEventListener("deviceorientation", handleOrientation, true);
          }
      }
      
      // If permission is required, show a button to trigger it.
      if (typeof DeviceOrientationEvent !== 'undefined' &&
          typeof DeviceOrientationEvent.requestPermission === 'function') {
          const button = document.createElement('button');
          button.id = "enableButton";
          button.innerHTML = "Enable Motion Controls";
          document.body.appendChild(button);
          button.addEventListener('click', () => {
              enableMotion();
              button.style.display = 'none';
          });
      } else {
          // Otherwise, add the event listener immediately.
          window.addEventListener("deviceorientation", handleOrientation, true);
      }
      
      // Animation loop: update particle positions with simple fluid-like physics.
      function animate() {
          requestAnimationFrame(animate);
          const positionsAttr = particles.geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
              // Update velocity by adding gravity, then applying damping.
              velocities[i*3]   += gravity.x;
              velocities[i*3+1] += gravity.y;
              velocities[i*3+2] += gravity.z;
              velocities[i*3]   *= 0.99;
              velocities[i*3+1] *= 0.99;
              velocities[i*3+2] *= 0.99;
              
              // Update positions.
              positionsAttr[i*3]   += velocities[i*3];
              positionsAttr[i*3+1] += velocities[i*3+1];
              positionsAttr[i*3+2] += velocities[i*3+2];
              
              // Simple boundaries: reverse velocity if a particle leaves the area.
              if (positionsAttr[i*3] < -range/2 || positionsAttr[i*3] > range/2) {
                  velocities[i*3] = -velocities[i*3];
              }
              if (positionsAttr[i*3+1] < -range/2 || positionsAttr[i*3+1] > range/2) {
                  velocities[i*3+1] = -velocities[i*3+1];
              }
              if (positionsAttr[i*3+2] < -range/2 || positionsAttr[i*3+2] > range/2) {
                  velocities[i*3+2] = -velocities[i*3+2];
              }
          }
          particles.geometry.attributes.position.needsUpdate = true;
          effect.render(scene, camera);
      }
      animate();
      
      // Adjust renderer size on window resize.
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          effect.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
