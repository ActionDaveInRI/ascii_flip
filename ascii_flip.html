<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>ASCII Particle Fluid Simulation</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; }
      canvas { display: block; }
    </style>
  </head>
  <body>
    <!-- Include Three.js from CDN -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <!-- Include AsciiEffect from an alternative CDN with crossorigin -->
    <script src="https://cdn.jsdelivr.net/gh/mrdoob/three.js@r128/examples/js/effects/AsciiEffect.js" crossorigin="anonymous"></script>
    <script>
      // Set up scene, camera, and renderer.
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(75, window.innerWidth/window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Wrap the renderer with the ASCIIEffect.
      const effect = new THREE.AsciiEffect(renderer, ' .:-+*=%@#', { invert: true });
      effect.setSize(window.innerWidth, window.innerHeight);
      effect.domElement.style.color = 'lime'; // ASCII text color
      effect.domElement.style.backgroundColor = 'black';
      document.body.appendChild(effect.domElement);
      
      // Create a particle system.
      const particleCount = 2000;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const range = 5; // area size
      
      // Initialize particles with random positions and small random velocities.
      for (let i = 0; i < particleCount; i++) {
          positions[i*3]   = (Math.random() - 0.5) * range;
          positions[i*3+1] = (Math.random() - 0.5) * range;
          positions[i*3+2] = (Math.random() - 0.5) * range;
          
          velocities[i*3]   = (Math.random() - 0.5) * 0.02;
          velocities[i*3+1] = (Math.random() - 0.5) * 0.02;
          velocities[i*3+2] = (Math.random() - 0.5) * 0.02;
      }
      geometry.setAttribute('position', new THREE.BufferAttribute(positions, 3));
      
      // Use a PointsMaterial. The ASCII effect will transform the rendering.
      const material = new THREE.PointsMaterial({ color: 0xffffff, size: 0.1 });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // Gravity vector to be influenced by device orientation.
      let gravity = new THREE.Vector3(0, -0.001, 0);
      
      // Update gravity based on device orientation.
      window.addEventListener("deviceorientation", (event) => {
          let beta  = event.beta  || 0;   // front-to-back tilt (range: -180 to 180)
          let gamma = event.gamma || 0;   // left-to-right tilt (range: -90 to 90)
          // Normalize: map gamma to x and beta to y, with a small scaling factor.
          let gx = THREE.MathUtils.clamp(gamma / 90, -1, 1) * 0.001;
          let gy = THREE.MathUtils.clamp(beta / 90, -1, 1) * 0.001;
          gravity.set(gx, gy, 0);
      }, true);
      
      // Animation loop: update particle positions using velocities and gravity.
      function animate() {
          requestAnimationFrame(animate);
          const positionsAttr = particles.geometry.attributes.position.array;
          for (let i = 0; i < particleCount; i++) {
              // Update velocity: add gravity, then apply damping to simulate fluid viscosity.
              velocities[i*3]   += gravity.x;
              velocities[i*3+1] += gravity.y;
              velocities[i*3+2] += gravity.z;
              velocities[i*3]   *= 0.99;
              velocities[i*3+1] *= 0.99;
              velocities[i*3+2] *= 0.99;
              
              // Update positions.
              positionsAttr[i*3]   += velocities[i*3];
              positionsAttr[i*3+1] += velocities[i*3+1];
              positionsAttr[i*3+2] += velocities[i*3+2];
              
              // Simple boundary conditions: bounce off the edges.
              if (positionsAttr[i*3] < -range/2 || positionsAttr[i*3] > range/2) {
                  velocities[i*3] = -velocities[i*3];
              }
              if (positionsAttr[i*3+1] < -range/2 || positionsAttr[i*3+1] > range/2) {
                  velocities[i*3+1] = -velocities[i*3+1];
              }
              if (positionsAttr[i*3+2] < -range/2 || positionsAttr[i*3+2] > range/2) {
                  velocities[i*3+2] = -velocities[i*3+2];
              }
          }
          particles.geometry.attributes.position.needsUpdate = true;
          effect.render(scene, camera);
      }
      animate();
      
      // Handle window resizing.
      window.addEventListener('resize', () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          effect.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
