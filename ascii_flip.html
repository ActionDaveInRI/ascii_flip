<!DOCTYPE html>
<html>
  <head>
    <meta charset="utf-8">
    <title>Colored ASCII FLIP Particle Simulation</title>
    <style>
      body { margin: 0; overflow: hidden; background: black; }
      pre { margin: 0; overflow: hidden; font-family: monospace; line-height: 0.8; }
      #enableButton {
        position: absolute;
        top: 20px;
        left: 20px;
        z-index: 100;
        padding: 20px 40px;
        background: #222;
        color: #fff;
        border: none;
        cursor: pointer;
        font-size: 24px;
        border-radius: 10px;
      }
    </style>
  </head>
  <body>
    <!-- Include Three.js -->
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script>
      // Custom ColoredAsciiEffect: uses an offscreen canvas to sample the WebGL canvas.
      class ColoredAsciiEffect {
        constructor(renderer, charSet, options) {
          this.renderer = renderer;
          this.charSet = charSet || " .:-+*=%@#";
          this.options = options || {};
          this.invert = this.options.invert || false;
          // Create a pre element to hold the ASCII text.
          this.domElement = document.createElement("pre");
          this.domElement.style.margin = "0";
          this.domElement.style.overflow = "hidden";
          this.domElement.style.position = "absolute";
          this.domElement.style.top = "0";
          this.domElement.style.left = "0";
          // Create an offscreen canvas to read pixel data.
          this.offscreenCanvas = document.createElement("canvas");
          this.offscreenCtx = this.offscreenCanvas.getContext("2d");
          // Bind setSize to ensure 'this' is correct.
          this.setSize = this.setSize.bind(this);
          this.setSize(window.innerWidth, window.innerHeight);
        }
        setSize(width, height) {
          this.width = width;
          this.height = height;
          this.domElement.style.width = width + "px";
          this.domElement.style.height = height + "px";
          this.offscreenCanvas.width = width;
          this.offscreenCanvas.height = height;
        }
        render(scene, camera) {
          // Render the scene.
          this.renderer.render(scene, camera);
          // Copy the WebGL canvas into the offscreen canvas.
          const webglCanvas = this.renderer.domElement;
          this.offscreenCtx.drawImage(webglCanvas, 0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
          const imageData = this.offscreenCtx.getImageData(0, 0, this.offscreenCanvas.width, this.offscreenCanvas.height);
          const data = imageData.data;
          // Divide the offscreen canvas into blocks for characters.
          const charWidth = 8;
          const charHeight = 16;
          const cols = Math.floor(this.offscreenCanvas.width / charWidth);
          const rows = Math.floor(this.offscreenCanvas.height / charHeight);
          let ascii = "";
          for (let j = 0; j < rows; j++) {
            for (let i = 0; i < cols; i++) {
              const x = Math.floor(i * charWidth + charWidth / 2);
              const y = Math.floor(j * charHeight + charHeight / 2);
              const index = (y * this.offscreenCanvas.width + x) * 4;
              const r = data[index];
              const g = data[index + 1];
              const b = data[index + 2];
              let brightness = (r + g + b) / 3;
              if (this.invert) brightness = 255 - brightness;
              const charIndex = Math.floor((brightness / 255) * (this.charSet.length - 1));
              const c = this.charSet[charIndex];
              ascii += `<span style="color: rgb(${r},${g},${b})">${c}</span>`;
            }
            ascii += "<br/>";
          }
          this.domElement.innerHTML = ascii;
        }
      }
    </script>
    <script>
      // ----- Simulation Setup -----
      // Basic scene, camera, and renderer.
      const scene = new THREE.Scene();
      const camera = new THREE.PerspectiveCamera(
        75, window.innerWidth / window.innerHeight, 0.1, 1000
      );
      camera.position.z = 5;
      
      const renderer = new THREE.WebGLRenderer();
      renderer.setSize(window.innerWidth, window.innerHeight);
      
      // Use our custom ColoredAsciiEffect.
      const effect = new ColoredAsciiEffect(renderer, " .:-+*=%@#", { invert: true });
      document.body.appendChild(effect.domElement);
      
      // Compute visible boundaries (Xâ€“Y plane at z=0) from camera settings.
      function updateBoundaries() {
        const distance = camera.position.z;
        const fovRad = THREE.MathUtils.degToRad(camera.fov);
        const height = 2 * Math.tan(fovRad / 2) * distance;
        const width = height * camera.aspect;
        return { left: -width/2, right: width/2, bottom: -height/2, top: height/2 };
      }
      let boundaries = updateBoundaries();
      
      // ----- Particle System -----
      const particleCount = 500;
      const geometry = new THREE.BufferGeometry();
      const positions = new Float32Array(particleCount * 3);
      const velocities = new Float32Array(particleCount * 3);
      const colors = new Float32Array(particleCount * 3);
      
      // Initialize particles within boundaries.
      for (let i = 0; i < particleCount; i++) {
          let x = Math.random() * (boundaries.right - boundaries.left) + boundaries.left;
          let y = Math.random() * (boundaries.top - boundaries.bottom) + boundaries.bottom;
          let z = (Math.random() - 0.5) * 0.5;
          positions[i * 3] = x;
          positions[i * 3 + 1] = y;
          positions[i * 3 + 2] = z;
          velocities[i * 3] = (Math.random() - 0.5) * 0.005;
          velocities[i * 3 + 1] = (Math.random() - 0.5) * 0.005;
          velocities[i * 3 + 2] = (Math.random() - 0.5) * 0.005;
          let normX = (x - boundaries.left) / (boundaries.right - boundaries.left);
          let normY = (y - boundaries.bottom) / (boundaries.top - boundaries.bottom);
          colors[i * 3] = normX;
          colors[i * 3 + 1] = normY;
          colors[i * 3 + 2] = 1 - (normX * normY);
      }
      geometry.setAttribute("position", new THREE.BufferAttribute(positions, 3));
      geometry.setAttribute("color", new THREE.BufferAttribute(colors, 3));
      
      // Use PointsMaterial with vertexColors enabled.
      const material = new THREE.PointsMaterial({ vertexColors: true, size: 0.1 });
      const particles = new THREE.Points(geometry, material);
      scene.add(particles);
      
      // ----- Forces & Repulsion -----
      let gravity = new THREE.Vector3(0, 0, 0);
      
      // Orientation handler for mobile devices.
      function handleOrientation(event) {
          let beta  = event.beta || 0;    // front-to-back tilt (-180 to 180)
          let gamma = event.gamma || 0;    // left-to-right tilt (-90 to 90)
          let gx = THREE.MathUtils.clamp(gamma / 90, -1, 1) * 0.05;
          let gy = -THREE.MathUtils.clamp(beta / 90, -1, 1) * 0.05;
          gravity.set(gx, gy, 0);
      }
      
      function enableMotion() {
          if (typeof DeviceOrientationEvent !== "undefined" &&
              typeof DeviceOrientationEvent.requestPermission === "function") {
              DeviceOrientationEvent.requestPermission()
              .then(permissionState => {
                  if (permissionState === "granted") {
                      window.addEventListener("deviceorientation", handleOrientation, true);
                  } else {
                      console.log("Permission not granted for DeviceOrientation.");
                  }
              })
              .catch(console.error);
          } else {
              window.addEventListener("deviceorientation", handleOrientation, true);
          }
      }
      
      if (typeof DeviceOrientationEvent !== "undefined" &&
          typeof DeviceOrientationEvent.requestPermission === "function") {
          const button = document.createElement("button");
          button.id = "enableButton";
          button.innerHTML = "Enable Motion Controls";
          document.body.appendChild(button);
          button.addEventListener("click", () => {
              enableMotion();
              button.style.display = "none";
          });
      } else {
          window.addEventListener("deviceorientation", handleOrientation, true);
      }
      
      // ----- Animation Loop -----
      let frameCount = 0;
      function animate() {
          requestAnimationFrame(animate);
          const t = performance.now() * 0.001;
          boundaries = updateBoundaries();
          const pos = particles.geometry.attributes.position.array;
          
          // Update velocities and positions with swirling force.
          for (let i = 0; i < particleCount; i++) {
              let swirlX = Math.sin(t + pos[i * 3 + 1] * 10) * 0.01;
              let swirlY = Math.cos(t + pos[i * 3] * 10) * 0.01;
              velocities[i * 3] = THREE.MathUtils.lerp(velocities[i * 3], gravity.x + swirlX, 0.3);
              velocities[i * 3 + 1] = THREE.MathUtils.lerp(velocities[i * 3 + 1], gravity.y + swirlY, 0.3);
              velocities[i * 3 + 2] = THREE.MathUtils.lerp(velocities[i * 3 + 2], gravity.z, 0.3) + (Math.random()-0.5)*0.005;
              pos[i * 3] += velocities[i * 3];
              pos[i * 3 + 1] += velocities[i * 3 + 1];
              pos[i * 3 + 2] += velocities[i * 3 + 2];
              if (pos[i * 3] < boundaries.left) { pos[i * 3] = boundaries.left; velocities[i * 3] = -velocities[i * 3]; }
              else if (pos[i * 3] > boundaries.right) { pos[i * 3] = boundaries.right; velocities[i * 3] = -velocities[i * 3]; }
              if (pos[i * 3 + 1] < boundaries.bottom) { pos[i * 3 + 1] = boundaries.bottom; velocities[i * 3 + 1] = -velocities[i * 3 + 1]; }
              else if (pos[i * 3 + 1] > boundaries.top) { pos[i * 3 + 1] = boundaries.top; velocities[i * 3 + 1] = -velocities[i * 3 + 1]; }
          }
          
          // Repulsion: enforce "personal space" between particles.
          const repulsionDistance = 0.15;
          const repulsionFactor = 0.01;
          for (let i = 0; i < particleCount; i++) {
              for (let j = i + 1; j < particleCount; j++) {
                  let dx = pos[i * 3] - pos[j * 3];
                  let dy = pos[i * 3 + 1] - pos[j * 3 + 1];
                  let dz = pos[i * 3 + 2] - pos[j * 3 + 2];
                  let dist = Math.sqrt(dx*dx + dy*dy + dz*dz);
                  if (dist < repulsionDistance && dist > 0) {
                      let force = repulsionFactor * (repulsionDistance - dist);
                      let fx = (dx / dist) * force;
                      let fy = (dy / dist) * force;
                      let fz = (dz / dist) * force;
                      velocities[i * 3] += fx;
                      velocities[i * 3 + 1] += fy;
                      velocities[i * 3 + 2] += fz;
                      velocities[j * 3] -= fx;
                      velocities[j * 3 + 1] -= fy;
                      velocities[j * 3 + 2] -= fz;
                  }
              }
          }
          
          // Update colors every 10 frames.
          frameCount++;
          if(frameCount % 10 === 0) {
              const col = particles.geometry.attributes.color.array;
              for (let i = 0; i < particleCount; i++) {
                  col[i * 3] = 0.5 + 0.5 * Math.sin(t + pos[i * 3]);
                  col[i * 3 + 1] = 0.5 + 0.5 * Math.sin(t + pos[i * 3 + 1]);
                  col[i * 3 + 2] = 0.5 + 0.5 * Math.sin(t + pos[i * 3 + 2]);
              }
              particles.geometry.attributes.color.needsUpdate = true;
          }
          
          particles.geometry.attributes.position.needsUpdate = true;
          effect.render(scene, camera);
      }
      animate();
      
      window.addEventListener("resize", () => {
          camera.aspect = window.innerWidth / window.innerHeight;
          camera.updateProjectionMatrix();
          renderer.setSize(window.innerWidth, window.innerHeight);
          effect.setSize(window.innerWidth, window.innerHeight);
      });
    </script>
  </body>
</html>
